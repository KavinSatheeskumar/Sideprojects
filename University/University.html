<!DOCTYPE html>
<html>
<head>
	<title>University</title>
	<link rel = "stylesheet" type = "text/css" href = "University_style.css" />
</head>
<body>
	<div id="menu">
		<h1 id="title">University Side Projects</h1>
		<canvas></canvas>
		<script src="animation.js"></script>
		<table id="menu_items">
			<tr>
				<td>
					<button class="projectButton" id="Button1">Basic Neural Network</button>
				</td>
				<td>
					<button class="projectButton" id="Button2">Purple Casimeir</button>
				</td>
			</tr>
		</table>
	</div>

	<div class="project">
		<h1 class="name" id="Basic Neural Network">Basic Neural Network</h1>
		<p class="description">This side project is an implementation of multilayer perceptron with backpropagation learning. It was made from scratch without the use of external libraries like NumPy or TensorFlow and it is capable of training a neural network to do various simple tasks like evaluating the exclusiveor function or calculating the square of the sine of a number.</p>
		<table id="NeuralNetworkCode">
			<tr>
				<th>Neural Network Class</th>
				<th>Linear Algebra Module</th>
			</tr>
			<tr>
				<td>
					<pre>
						<code class="python">
from lin_module import *
import random

class Network:
    def __init__(self,ls,r):
        self.rate = r
        self.layer_sizes = ls

        self.layers = [
                [0 for _ in range(self.layer_sizes[i])]
                for i in range(len(self.layer_sizes))
            ]

        self.e_layers = self.layers[:]

        self.z_layers = self.layers[:]

        self.webbs = [
                [
                    [random.uniform(-5,5) for _ in range(self.layer_sizes[i+1])]
                    for __ in range(self.layer_sizes[i])
                ]
                for i in range(len(self.layer_sizes)-1)
            ]

        self.biases = [
                [random.uniform(-5,5) for _ in range(self.layer_sizes[i+1])]
                for i in range(len(self.layer_sizes)-1)
            ]

    def evaluate(self,i):
        self.layers[0] = i

        for i in range(len(self.layers)-1):
            self.z_layers[i+1] = add_vec(matrix_mult(self.webbs[i],self.layers[i]), self.biases[i])
            self.layers[i+1] = sigmoid(self.z_layers[i+1])

        return (self.layers[-1])

    #This function has brought me so much pain...
    def train(self,example):
        self.evaluate(example[0])

        diff = sub_vec(self.layers[-1], example[1])
        self.e_layers[-1] = mult_vec(diff,d_sigmoid(self.z_layers[-1]))

        for x in range(len(self.e_layers)-1,0,-1):
            trans_prod = matrix_mult(transpose(self.webbs[x-1]),self.e_layers[x])
            self.e_layers[x-1] = mult_vec(trans_prod,d_sigmoid(self.z_layers[x-1]))

        for i in range(len(self.biases)):
            self.biases[i] = sub_vec(self.biases[i],scale(self.rate,self.e_layers[i+1]))

        for x in range(len(self.webbs)):
            for i in range(len(self.webbs[x])):
                for j in range(len(self.webbs[x][0])):
                    self.webbs[x][i][j] -= self.rate*(self.layers[x][i]*self.e_layers[x+1][j])

    def display(self):
        for x in range(len(self.layers)-1):
            for y in self.webbs[x]:
                print(y)
            print("----")
            print(self.biases[x])
            print("====")

    def cost(self, example):
        self.evaluate(example[0])

        output = 0

        for x in range(len(example[1])):
            output += (self.layers[-1][x] - example[1][x]) ** 2

        return output
						</code>
					</pre>
				</td>
				<td>
					<pre>
						<code class="python">
e = 2.7182818284590452353602874713526624977572470936999595749669676

def add_vec(a,b):
    output = None
    if len(a) == len(b):
        output = [a[i] + b[i] for i in range(len(a))]
        return output
    else:
        raise Exception("Input vectors different length")

def sub_vec(a,b):
    output = None
    if len(a) == len(b):
        output = [a[i] - b[i] for i in range(len(a))]
        return output
    else:
        raise Exception("Input vectors different length")

def mult_vec(a,b):
    output = None
    if len(a) == len(b):
        output = [a[i] * b[i] for i in range(len(a))]
        return output
    else:
        raise Exception("Input vectors different length")

def scale(s,v):
    output = [s*v[i] for i in range(len(v))]
    return output

def matrix_mult(M,v):
    if len(M) == len(v):
        temp = [scale(v[i],M[i]) for i in range(len(v))]
        output = [0 for _ in range(len(temp[0]))]
        for x in temp:
            output = add_vec(output,x)
        return output
    else:
        raise Exception(M, v)

def transpose(M):
    output = []
    for x in range(len(M[0])):
        temp = []
        for y in range(len(M)):
            temp.append(M[y][x])
        output.append(temp)

    return output

def sigmoid(v):
    output = []
    for x in v:
        try:
            output.append(1/(1+e**(-x)))
        except OverflowError:
            if x > 0:
                output.append(1)
            else:
                output.append(0)
    return output

def d_sigmoid(v):
    output = []
    for s in v:
        try:
            output.append((e**(-s)/((1+e**(-s))**2)))
        except OverflowError:
            output.append(0)
    return output





						</code>
					</pre>
				</td>
			</tr>
		</table>
	</div>

	<div class="project">
		<h1 class="name" id="Purple Casimeir">Purple Casimeir</h1>
		<p class="description"></p>
	</div>

<footer>
	<script src="scroll.js"></script>
	<link rel="stylesheet" href="highlight/styles/dark.css">
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</footer>
</html>